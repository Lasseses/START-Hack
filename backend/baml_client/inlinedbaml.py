###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml-py
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401,F821
# flake8: noqa: E501,F401,F821
# pylint: disable=unused-import,line-too-long
# fmt: off

file_map = {
    
    "api_request.baml": "class Tool {\n  type ToolType @description(\"The type of tool to be used.\")\n  inputs string[] @description(\"A list of key-value pairs that define the input for the tool. <arg-name>=<arg-value>\")\n}\n\n// alternative approach to consider let llm choose tool per tile and then in a next llm call set input per tool. for now trying to do this in one go \n\nenum ToolType {\n    OHLCV @description( #\"Retrieve historical OHLCV data for a given company.\n\n    This function searches for a company by name and retrieves its historical \n    price data (OHLCV: Open, High, Low, Close, Volume) via an HTTP POST request to a remote API.\n\n    Args:\n        symbol (str): The name or ticker of the company (e.g., \"banco santander\").\n        first (str): The start date for retrieving data, in the format \"dd.mm.yyyy\".\n        last (str): The end date for retrieving data, in the format \"dd.mm.yyyy\". \n            If provided, data will be fetched up to this date.\n\n    Returns:\n        dict: A dictionary containing the JSON response from the API with the historical data.\"#)\n\n    SEARCHWITHCRITERIA @description( #\"Search for companies or stocks based on specified criteria.\n\n    This function accepts a query string containing search criteria in JSON format.\n    The JSON should follow a dictionary schema where keys are attributes and values\n    define the logical condition for filtering (i.e. an actual value or similar). For example:\n    \n        '{\"ebitda\": \"is positive\", \"employees\": \"more than 10000\"}' i.e. '{\"criteria\": \"condition\"}'\n    Args:\n        query (str): A JSON-formatted string specifying the search criteria. Possible search criteria are: \n        [\n            'revenue',\n            'net_income',\n            'EBITDA',\n            'operating_income',\n            'EPS',\n            'dividend_yield',\n            'PE_ratio',\n            'market_cap',\n            'employees',\n            'debt_to_equity',\n            'return_on_equity',\n            'operating_margin',\n            'profit_margin',\n            'free_cash_flow',\n            'total_assets',\n            'total_liabilities',\n            'current_ratio',\n            'quick_ratio',\n            'sector',\n            'industry',\n            'country',\n            'founded_year',\n            'exchange',\n            'short_interest',\n            'dividend_payout_ratio',\n            'insider_ownership',\n            'institutional_ownership',\n            'gross_margin',\n            'EPS_growth',\n            'price_target'\n        ]\n    \n    Returns:\n        dict: A JSON dictionary representing the search results table.\"#)\n\n  FETCH_ASSET_ALLOCATION @description( #\"Retrieves the asset allocation for a specified customer from a JSON file.\n\n    This function reads a JSON file containing multiple customers' financial portfolios \n    and extracts the asset allocation for the given customer. The returned data is \n    structured as a list of dictionaries, where each dictionary represents an asset with \n    its corresponding allocation percentage.\n\n    Args:\n        customer_name (str): The name of the customer whose asset allocation is to be retrieved.\n\n    Returns:\n        list[dict]: A list of dictionaries, each containing:\n            - \"asset\" (str): The name of the asset.\n            - \"allocation\" (float): The percentage allocation of the asset.\n  \"#)        \n  \n}\n\n\nfunction GenerateToolCalls(title: string, type: string, description: string, context: string, date: string) -> Tool {\n  client \"CustomGemini2Flash\" \n  prompt #\"\n    To generate a diagram, decide which of the available tools should be used to retrieve the required data. Also output the input values needed to use the tool.\n    The diagram is of type {{ type }} and should show: {{ title }}.\n    Here is a description of the content to be displayed in the diagram: \n    {{ description }}\n\n    {% if context %} Consider the following context information:\n    {{ context }}{% endif %}\n    {% if date %}Todays date is: {{ date }}{% endif %}\n    \n\n    {{ ctx.output_format }}\n  \"# \n}\n\n\ntest test_tool_calls {\n  functions [GenerateToolCalls]\n  args {\n    title \"SAP Stock Price (1 Year)\"\n    type \"CANDLE\"\n    description \"Candlestick chart displaying SAP's stock price movement over the past year, showing open, close, high, and low prices for each period.\"\n    context \"\"\n    date \"2025-03-20\"\n  }\n}\n\n",
    "canvas.baml": "class Canvas {\n  tiles Tile[] @description(\"A list of tiles on the canvas.\")\n}\n\nclass Tile {\n  title string @description(\"A title that describes the content of this tile.\")\n  type DiagramType @description(\"The type of diagram or content to be displayed in this tile.\")\n  content string @description(\"A short description of the content to be displayed in this tile. This should contain specific information on the data to be displayed. It needs to consider what the diagram type is suitable to show.\")\n}\n\nenum DiagramType {\n  LINE @description(\"Line chart diagram time. This can show historical stock price data.\")\n  PIE @description(\"A pie chart diagram. This can show asset allocation of a person.\")\n  CANDLE @description(\"Candle chart diagram. This can show historical stock price data.\")\n  TABLE @description(\"A table. This can be used to find companies or stocks which fulfill certain criteria. The tabel will then show the values of these criteria.\")\n}\n// line: call_ohlcv\n// pie: fetch_asset_allocation\n// candle: call_ohlcv\n// table: call_searchwithcriteria\n// KPI @description(\"A simple KPI number\") - not working yet\n// BAR @description(\"Bar chart diagram\") - not working yet\n\n\nfunction GenerateCanvas(user_input: string, context: string ) -> Canvas {\n  client \"CustomGemini2Flash\" \n  prompt #\"\n    Based on the following user input, generate a canvas that displays the requested information in tiles that each contain an appropriate diagram.\n    {{ user_input }}\n\n    {% if context %}\n    Use the following additional context:\n    {{ context }}\n    {% endif %}\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n\ntest test_canvas {\n  functions [GenerateCanvas]\n  args {\n    user_input #\"\n    show me how the stock price of Apple and one competitor have developed over the past four weeks. also find a company that has a similar price to earnings ratio to apple.\"#\n    context #\"use 2 - 5 tiles as needed.\"#\n  }\n}\n",
    "clients.baml": "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\n\nclient<llm> CustomGPT4o {\n  provider openai\n  options {\n    model \"gpt-4o\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\nclient<llm> CustomGPT4oMini {\n  provider openai\n  retry_policy Exponential\n  options {\n    model \"gpt-4o-mini\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\nclient<llm> CustomSonnet {\n  provider anthropic\n  options {\n    model \"claude-3-5-sonnet-20241022\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\n\nclient<llm> CustomHaiku {\n  provider anthropic\n  retry_policy Constant\n  options {\n    model \"claude-3-haiku-20240307\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\nclient<llm> CustomGemini2Flash {\n  provider google-ai\n  options {\n    model \"gemini-2.0-flash\"\n    api_key env.GOOGLE_AI_API_KEY\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/round-robin\nclient<llm> CustomFast {\n  provider round-robin\n  options {\n    // This will alternate between the two clients\n    strategy [CustomGPT4oMini, CustomHaiku]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/fallback\nclient<llm> OpenaiFallback {\n  provider fallback\n  options {\n    // This will try the clients in order until one succeeds\n    strategy [CustomGPT4oMini, CustomGPT4oMini]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/retry\nretry_policy Constant {\n  max_retries 3\n  // Strategy is optional\n  strategy {\n    type constant_delay\n    delay_ms 200\n  }\n}\n\nretry_policy Exponential {\n  max_retries 2\n  // Strategy is optional\n  strategy {\n    type exponential_backoff\n    delay_ms 300\n    multiplier 1.5\n    max_delay_ms 10000\n  }\n}\n\n",
    "generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"python/pydantic\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../\"\n\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n    // The BAML VSCode extension version should also match this version.\n    version \"0.80.1\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode sync\n}\n",
}

def get_baml_files():
    return file_map